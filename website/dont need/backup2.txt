instructionStructure = new Array();
var levelCode = null;
var myInterpreter = null;
var highlightPause = false;
var latestCode = '';
var runTimeout = null;
var state = [];


function getBookValue(bookIndex) {
  state
}

Blockly.Blocks['select_hand_position'] = {
  init: function () {
    this.appendDummyInput()
      .appendField("Move");
    this.appendDummyInput()
      .appendField(new Blockly.FieldDropdown([["left hand", "Left hand"], ["right hand", "Right hand"]]), "handSelect")
      .appendField("to index")
      .appendField(new Blockly.FieldNumber(0), "indexSelect");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(290);
    this.setTooltip("");
    this.setHelpUrl("");
  }
};
Blockly.JavaScript['select_hand_position'] = function (block) {
  var dropdown_handselect = block.getFieldValue('handSelect');
  var number_indexselect = block.getFieldValue('indexSelect');
  var input = '["' + dropdown_handselect + '",' + number_indexselect + ']';
  var code = 'pushInstruction("select_hand_position",' + input + ');'
  return code;
};


Blockly.Blocks['grab_book'] = {
  init: function () {
    this.appendDummyInput()
      .appendField("Grab");
    this.appendDummyInput()
      .appendField(new Blockly.FieldNumber(0), "indexSelect")
      .appendField("with")
      .appendField(new Blockly.FieldDropdown([["left hand", "Left hand"], ["right hand", "Right hand"]]), "handSelect");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(290);
    this.setTooltip("");
    this.setHelpUrl("");
  }
};
Blockly.JavaScript['grab_book'] = function (block) {
  var number_indexselect = block.getFieldValue('indexSelect');
  var dropdown_handselect = block.getFieldValue('handSelect');
  var input = '["' + dropdown_handselect + '",' + number_indexselect + ']';
  var code = 'pushInstruction("grab_book",' + input + ');'
  return code;
};

Blockly.Blocks['place_book'] = {
  init: function () {
    this.appendDummyInput()
      .appendField("Place with");
    this.appendDummyInput()
      .appendField(new Blockly.FieldDropdown([["left hand", "Left hand"], ["right hand", "Right hand"]]), "handSelect")
      .appendField("at index")
      .appendField(new Blockly.FieldNumber(0), "indexSelect");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(290);
    this.setTooltip("");
    this.setHelpUrl("");
  }
};
Blockly.JavaScript['place_book'] = function (block) {
  var dropdown_handselect = block.getFieldValue('handSelect');
  var number_indexselect = block.getFieldValue('indexSelect');
  var input = '["' + dropdown_handselect + '",' + number_indexselect + ']';
  var code = 'pushInstruction("place_book",' + input + ');';
  return code;
};


function clearArray() {
  instructionStructure = [];
}

function showInstructions() {
  return JSON.stringify(instructionStructure);
}

function isEqual(firstBlock, secondBlock) {
  // tests types of blocks, if not the same then return false   
  var type = Object.prototype.toString.call(firstBlock);
  if (type !== Object.prototype.toString.call(secondBlock)) return false;


  // tests if it they are actually an object or array, if not then return false
  // only need to test one as previous if statement ensures same type  
  if (['[object Array]', '[object Object]'].indexOf(type) < 0) return false;

  // test to make sure they are the same length
  // if type array then use .length
  // if Object then get array of object keys and then use .length on the result  
  var firstBlockLen = type === '[object Array]' ? firstBlock.length : Object.keys(firstBlock).length;
  var secondBlockLen = type === '[object Array]' ? secondBlock.length : Object.keys(secondBlock).length;
  if (firstBlockLen !== secondBlockLen) return false;

  // Compare two items
  // placed before use
  var compare = function (item1, item2) {

    // get the type of the items
    //checks types of the item
    var itemType = Object.prototype.toString.call(item1);
    if (itemType !== Object.prototype.toString.call(item2)) return false;

    // if they are of type Object or array, call isEqual recursively for comparison
    // if it comes back false, then so does the higher function call
    if (['[object Array]', '[object Object]'].indexOf(itemType) >= 0) {
      if (!isEqual(item1, item2)) return false;
    }

    // else do a comparison on values
    else {
      // If it's a function, convert to a string and compare
      // Otherwise, just compare
      if (itemType === '[object Function]') {
        if (item1.toString() !== item2.toString()) return false;
      } else {
        if (item1 !== item2) return false;
      }
    }
    return true;
  };

  // Compare properties
  var match;
  if (type === '[object Array]') {
    for (var i = 0; i < firstBlockLen; i++) {
      if (!compare(firstBlock[i], secondBlock[i])) return false;
    }
  } else {
    for (var key in firstBlock) {
      if (firstBlock.hasOwnProperty(key)) {
        if (!compare(firstBlock[key], secondBlock[key])) return false;
      }
    }
  }

  // if no tests failed, return true to signify they are the same
  return true
}

function getSolution(levelCode) {
  switch (levelCode) {
    case 1:
      solutionArray = [{ "blockName": "select_hand_position", "hand": "Left hand", "index": "0" },
      { "blockName": "grab_book", "hand": "Left hand", "index": "0" },
      { "blockName": "select_hand_position", "hand": "Left hand", "index": "1" },
      { "blockName": "place_book", "hand": "Left hand", "index": "1" }]
      break;
  }
  return solutionArray;
}

function compareSolutions(levelCode, instructionNumber) {
  solutionArray = getSolution(levelCode);

  if (isEqual(instructionStructure[instructionNumber - 1], solutionArray[instructionNumber - 1]) === false) {
    alert("Incorrect on highlighted step: " + instructionNumber);
    return false;
  } else if ((instructionNumber) === solutionArray.length) {
    alert("congrats you did it!");
  }
  // Called if no wrong blocks, but isnt final solution -
  // checks for interpreter value being null as its set to null once the interpreter evals 
  // the currently compared block as being the users last.
  else if (myInterpreter === null) {
    alert("All is good so far, but you are not quite finished!, Keep it up!");
  }
  return true;

}


function initApi(interpreter, scope) {
  // Add an API function for the alert() block, generated for "text_print" blocks.
  interpreter.setProperty(scope, 'alert',
    interpreter.createNativeFunction(function (text) {
      text = text ? text.toString() : '';
      outputArea.value += '\n' + text;
    }));

  // Add an API function for highlighting blocks.
  wrapper = function (id) {
    id = id ? id.toString() : '';
    return interpreter.createPrimitive(highlightBlock(id));
  };
  interpreter.setProperty(scope, 'highlightBlock',
    interpreter.createNativeFunction(wrapper));

  // Add an API function for pushing instructions to instructionStructure
  wrapper = function (blockName, inputs) {
    return pushInstruction(blockName, inputs);
  };
  interpreter.setProperty(scope, 'pushInstruction',
    interpreter.createNativeFunction(wrapper));
}



function highlightBlock(id) {
  workspace.highlightBlock(id);
  highlightPause = true;
}


function pushInstruction(blockName, inputs) {
  var instruction = null;
  switch (blockName.toString()) {
    case "place_book":
    case "grab_book":
    case "select_hand_position":
      instruction = {
        blockName: blockName,
        hand: inputs.a[0].toString(),
        index: inputs.a[1].toString()
      };
      instructionStructure.push(instruction);
      break;

    default:
      throw 'attempted to push unknown instruction block';
  }
}


function resetStepUi(clearOutput) {
  workspace.highlightBlock(null);
  highlightPause = false;
  if (clearOutput) {
    outputArea.value = 'Program output:\n=================';
  }
}


function generateCodeAndLoadIntoInterpreter() {
  // Generate JavaScript code and parse it.
  Blockly.JavaScript.STATEMENT_PREFIX = 'highlightBlock(%1);\n';
  Blockly.JavaScript.addReservedWords('highlightBlock');
  latestCode = Blockly.JavaScript.workspaceToCode(workspace);
  resetStepUi(true);
}


window.stepCode = function (level) {
  if (!myInterpreter) {
    // First statement of this code.
    // Clear the program output.
    levelCode = level;
    resetStepUi(true);
    clearArray();
    myInterpreter = new Interpreter(latestCode, initApi);

    // And then show generated code in an alert.
    // In a timeout to allow the outputArea.value to reset first.
    setTimeout(function () {
      // alert('Ready to execute the following code\n' +
      //   '===================================\n' + latestCode);
      // highlightPause = true;
      stepCode();
    }, 1);
    return;
  }
  highlightPause = false;
  do {
    try {
      var hasMoreCode = myInterpreter.step();
    } finally {
      if (!hasMoreCode) {
        // Program complete, no more code to execute.
        outputArea.value += '\n\n<< Program End >>';
        console.log(showInstructions());
        myInterpreter = null;
        resetStepUi(false);
        runButton.innerText = "Run";

        // Cool down, to discourage accidentally restarting the program.
        stepButton.disabled = 'disabled';
        runButton.disabled = 'disabled';
        setTimeout(function () {
          stepButton.disabled = '';
          runButton.disabled = '';
        }, 2000);

        return;
      }
    }
    // Keep executing until a highlight statement is reached,
    // or the code completes or errors.
  } while (hasMoreCode && !highlightPause);
}

function runCode(level) {
  // var runButton = document.getElementById("runButton");
  if (runButton.innerText === "Run") {
    runButton.innerText = "Pause";
  } else {
    clearTimeout(runTimeout);
    runButton.innerText = "Run";
    return;
  }
  // loops step execution automatically until either
  // an error is met (checked in stepExecution)
  // or it finishes execution of all user blocks (indicated by interpreter being null)
  function nextStep() {
    if (stepExecution(level) && myInterpreter !== null) {
      runTimeout = window.setTimeout(nextStep, 1000);
    }
  }
  nextStep();
}


function stepExecution(level) {
  if (myInterpreter == null) {
    setupOnStart(levelCode);
  }
  //execute
  stepCode(level);
  // update the html and state anyhow 
  updateState();
  updateHTML();
  if (instructionStructure.length !== 0 && compareSolutions(levelCode, instructionStructure.length) === false) {
    lastErrorArea.value = 'FIRST ENCOUNTERED ERROR ON LAST ITERATION: \n \n Wrong on block number '
      + instructionStructure.length.toString();
    clearArray();
    myInterpreter = null;
    resetStepUi(false);
    return false;
  }
  return true;
}


function reset() {
  myInterpreter = null;
  resetStepUi(true);
  clearArray();
  runButton.innerText = "Run";
  setupOnStart(levelCode);
}


function setupState(levelCode) {
  switch (levelCode) {
    case 1:
      state = [
        ['', ['Left hand', '<img style="display:block;" width="100%" height="100%" src="./media/left_hand.svg" />']],
        ['', ''],
        [['book1', '<img style="display:block;" width="100%" height="100%" src="./media/book_1.svg" />'], ''],
      ];
      break;
  }
}

function findIndexInState(id) {
  for (var i = 0; i < state.length; i++) {
    var row = state[i];
    for (var j = 0; j < row.length; j++) {
      if (row[j][0] === id) {
        return [i, j];
      }
    }
  }
}

function clearStateCell(row, column) {
  state[row][column] = '';
}

function setStateCell(row, column, data) {
  state[row][column] = data;
}

function returnKeyValue(obj, keyIndex) {
  return obj[Object.keys(obj)[keyIndex]]
}

function bookBelowHand(positionOfHand) {
  if (state[1][positionOfHand[1]] !== '') {
    return true;
  }
  return false;
}

function updateState() {

  var latestIndex = instructionStructure.length - 1;
  if (latestIndex == -1) {
    return;
  }
  var instruction = instructionStructure[latestIndex];
  switch (returnKeyValue(instruction, 0)) {

    case "select_hand_position":
      var index = findIndexInState(returnKeyValue(instruction, 1));
      var tempHand = state[index[0]][index[1]];
      if (bookBelowHand(index)) {
        var tempBook = state[1][index[1]];
        clearStateCell(1, index[1]);
        setStateCell(1, returnKeyValue(instruction, 2), tempBook)
      }
      clearStateCell(index[0], index[1]);
      setStateCell(index[0], returnKeyValue(instruction, 2), tempHand);

      break;

    case "grab_book":
      // get whatever book is in specified index of instruction on row 3
      // give to temp
      // clear
      // and move book up 1 row  
      // NOTE: MUST ONLY ALLOW GRAB IF HAND IS ABOVE IT!
      // maybe does this through viewing of the state by calling a function before updating?                   
      var temp = state[2][returnKeyValue(instruction, 2)];
      clearStateCell(2, returnKeyValue(instruction, 2));
      setStateCell(1, returnKeyValue(instruction, 2), temp);
      break;

    case "place_book":
      // get whatever book is under the column index of specified hand in second row
      // place into row 3 in same column index
      var index = findIndexInState(returnKeyValue(instruction, 1));
      var temp = state[1][index[1]];
      clearStateCell(1, index[1]);
      setStateCell(2, returnKeyValue(instruction, 2), temp);
      break;

  }
}

function updateHTML() {
  for (var i = 0; i < state.length; i++) {
    var row = state[i];
    for (var j = 0; j < row.length; j++) {
      if (state[i][j][1] != null) {
        table.rows[i].cells[j].innerHTML = state[i][j][1];
      } else {
        table.rows[i].cells[j].innerHTML = '';
      }
    }
  }
}


function setupOnStart(lvl) {
  setupState(lvl);
  updateHTML();
}

function displayHelpModal() {
  $('#myModal').modal('toggle');
}

